---
title: "Hsieh_et_al_2008_repro"
output: html_document
---

# Introduction:

Hsieh et al. 2008, American Naturalist propose a method to detect non-linearity in ecological time series using the simplex and s-map projections developed by Sugihara and co-workers. Generally, non-linear time series analysis requires long-time series to detect signals. The approach by Hsieh et al. combines individual time series of ecologically similar species into one long time series to which simplex and s-maps can be applied (termed *Dewdrop regression* by the authors). To illustrate their approach, a five species competition model was used to generate time series and the ability of the method to get back the original parameter values of the simulation tested under various levels of noise and lengths of the time series.

The goals for this reproduction are:
* understanding simplex and s-maps as forecasting tools using the recently released rEDM package.
* understand the approach taken to combine several short time series into one long time series to detect non-linearity and make useful forecasts
* set up a simulation model of multi-species competition

# Step 1: Simulate 5 species dynamics:

First we reproduced the dynamics of the 5 species community as follows:

* a multispecies competition model based on the logistic map
* all alphas set to 0.05
* growth rate r is 3.57 (just below the chaotic regime)
* 15% process noise noise was added to the time series (to the alphas)
* additionally, 5% observation noise was added to the generated time series
* time series of abundance for 1000 steps generated for each species

The following R code implements the simulation model:
```{r, eval=T}
# This code implements a multispecies competition model based on the logistic map (https://en.wikipedia.org/wiki/Logistic_map)
# the equilibrium density depends on the growth rate (steady state at values between 1 and 2, extinction below 1, chaos > 3.7, fluctuations > 3)

# set seed
set.seed(190981)

## Specify the number of species
S <- 5

#growth rate in the eight-mode oscillation regime below the threshold to chaos
r <- 3.57

# specify alphas
a <- 0.05

# simulate 1000 time steps
t=seq(1,1000, by=1)

# specify matrix to hold results
N <- matrix(nrow=S, ncol=length(t))

# set initial conditions randomly
N[,1] <- runif(S)

# simulate dynamics using the discrete logistic growth model; add process noise at the end
for (i in 1:(length(t)-1)){
  
  for (j in 1:5){

    N[j,i+1] = (r * N[j,i] * (1- N[j,i]) - a*sum(N[-j,i]) ) * runif(1,0.85,1.15)
    
  }
}

# add some observation noise to time series
N <- N * runif(length(N), 0.95, 1.05)

# plot results
matplot(t,t(N[1:S,]), "l",ylim=c(0,1), xlim=c(0,100),col=2:5)


output <- as.data.frame(t(N[1:S,]))
names(output) <- paste0("species ", 1:S)

# check for correlation in abundances
#plot(output$`species 1`, output$`species 5`)

#write.csv(output, "/Users/Frank/Documents/Git projects/RREEBES/Hsieh_et_al_2008/data/5sp_comp_sim_data.csv", row.names=F)

five_sp_comp <- read.csv("/Users/Frank/Documents/Git projects/RREEBES/Hsieh_et_al_2008/data/5sp_comp_sim_data.csv")
#names(five_sp_comp) <- c("time", paste0("species.", 1:5))
five_sp_comp$time <- seq(1,1000)

five_sp_comp <- five_sp_comp[,c(6,1:5)]

```

# Are species dynamically similar? Look at state-space plot of the different species:

```{r, state-space, eval=T}
Embed <- function(X, dimension=4) {
  E_X <- matrix(NA, length(X)-dimension, dimension)
  for(i in 1:dimension)
    E_X[,i] <- X[(1+i-1):(length(X)-dimension+i-1)]
  E_X
}


library(plot3D)

embed_sp5 <- Embed(five_sp_comp[,c(2)], dimension=3)
colnames(embed_sp5) <- paste0("embed",1:3)
points3D(x = embed_sp5[,1],
       y = embed_sp5[,2],
       z = embed_sp5[,3],  col="blue")

embed_sp5 <- Embed(five_sp_comp[,c(3)], dimension=3)
points3D(x = embed_sp5[,1],
       y = embed_sp5[,2],
       z = embed_sp5[,3],  col="red", add=T)


```

Next we try to reproduce figure 1 from the publication:
```{r}
# fig 1 A
#plot(five_sp_comp[,3], five_sp_comp[,5], xlim=c(0,1.1), ylim=c(0,1.1))

# fit AR(4) model
ar_mod <-  ar(as.ts(five_sp_comp[,c(5)]), FALSE, 4)
#str(ar_mod)

ar_mod$ar

sp3_ar_prediction <- vector("numeric", 1000)
# predict species 3 based on species 5
for (t in 5:1000){

sp3_ar_prediction[t] = ar_mod$x.mean + ar_mod$ar[1] * five_sp_comp[(t-1),3] + ar_mod$ar[2] * five_sp_comp[(t-2),3]  + ar_mod$ar[3] * five_sp_comp[(t-3),3] + ar_mod$ar[4] * five_sp_comp[(t-4),3]

}

#plot(sp3_ar_prediction, five_sp_comp[,3])

```


## Use rEDM package to make predictions

# Step 2: Apply simplex projection from rEDM package to simulated time series (predicting species 5)

Predict last 15 time steps of species 1 based on previous 985 time steps of same species.

```{r, echo=FALSE}
# now load our simulated time series

#load rEDM package
library(rEDM)

simplex_mod_stats_sp5_1 <- simplex(five_sp_comp$species.5, lib = c(1, 500), pred = c(501, NROW(five_sp_comp$species.5)),
                norm_type = c("L2 norm"), E = 1:10,
                tau = 1, tp = 1, num_neighbors = "e+1", stats_only = T,
                exclusion_radius = NULL, epsilon = NULL, silent = FALSE)

# check number of embedding dimensions
plot(simplex_mod_stats_sp5_1$E, simplex_mod_stats_sp5_1$rho, type="l", xlab = "Embedding dimension (E)", ylab="Forecast skill (rho)")

# look at actual forecasting skill (we have to refit the model and set stats_only to FALSE) when predicting species 1 with data from species 1
simplex_mod_pred_sp5_2 <- simplex(five_sp_comp$species.5, lib = c(1, 500), pred = c(501, NROW(five_sp_comp$species.5)),
                norm_type = c("L2 norm"),  E = 1:10,
                tau = 1, tp = 1, num_neighbors = "e+1", stats_only = F,
                exclusion_radius = NULL, epsilon = NULL, silent = FALSE)

sp5_observations  <- simplex_mod_pred_sp5_2[[3]]$model_output$obs
sp5_predictions  <- simplex_mod_pred_sp5_2[[3]]$model_output$pred

#head(simplex_mod_pred_sp5_2[[3]]$model_output$time)

# compare data with predictions visually
plot(five_sp_comp$time, five_sp_comp$species.5, "l", ylim=c(0,1), xlim = c(900,1000), xlab="time step", ylab="abundance species 5")
par(new=T)
plot(simplex_mod_pred_sp5_2[[3]]$model_output$time, simplex_mod_pred_sp5_2[[3]]$model_output$pred, "l", lty = 2, col="red", ylim=c(0,1), xlim = c(900,1000), xlab="time step", ylab="abundance species 5")

#plot(sp5_observations, sp5_predictions, "p", lty = 2, col="red", ylim=c(0,1), xlim=c(0,1))
#abline(0,1)


```


# Step 3: apply s-maps to simulated time series with best embedding dimension as determined by simplex (predicting species 5)

```{r}
# now use smap with E dimensions (identified with Simplex)
smap_out <- s_map(five_sp_comp$species.5, lib = c(1, 985), pred = c(986,NROW(five_sp_comp$species.5)), stats_only = T,
                  norm_type = c("L2 norm"), E = 4)
#smap_out

# plot theta against forecasting skill
plot(smap_out$theta, smap_out$rho, type="l", xlab = "Non-linearity", ylab="Forecast skill (rho)")

smap_pred <- s_map(five_sp_comp$species.5, lib = c(1, 985), pred = c(986,NROW(five_sp_comp$species.5)), stats_only = F,
                  norm_type = c("L2 norm"), E = 4, theta = 4)

sp5_observations  <- smap_pred[[1]]$model_output$obs
sp5_predictions  <- smap_pred[[1]]$model_output$pred

#plot(sp5_observations, sp5_predictions)
#abline(0,1)
```

# Step 4: test co-predictability (use library based on species 3 to predict species 5)

```{r}
# predict species 3 based on embeddings in species 5
block_data <- five_sp_comp[,c(1,4,6)]
n <- NROW(block_data$species.5)
block_data$species.5m1 <- c(NA, block_data$species.5[-n])
block_data$species.5m2 <- c(NA, block_data$species.5m1[-n])
block_data$species.5m3 <- c(NA, block_data$species.5m2[-n])
block_data$species.5m4 <- c(NA, block_data$species.5m3[-n])

block <- block_lnlp(block_data, lib = c(1, 1000), pred = c(1,NROW(block_data)),
  norm_type = c("L2 norm"), 
  method = c("s-map"), tp = 1, num_neighbors = "0.0001", 
  columns = c("species.3",  "species.5m1", "species.5m2", "species.5m3", "species.5m4"), target_column = c("species.3"), stats_only = T, first_column_time = T)
block

block <- block_lnlp(block_data, lib = c(1, 1000), pred = c(1,NROW(block_data)),
  norm_type = c("L2 norm"), 
  method = c("s-map"), tp = 1, num_neighbors = "0.0001", 
  columns = c("species.3", "species.5m1", "species.5m2", "species.5m3", "species.5m4"), target_column = c("species.3"), stats_only = F, first_column_time = T)

sp3_observations  <- block[[1]]$model_output$obs
sp3_predictions  <- block[[1]]$model_output$pred

#plot(sp3_observations, sp3_predictions)
#abline(a=0,b=1)

```


## assemble Figure 1 from previous chunk:

```{r, fig.width=9, fig.height=5}
par(mfrow=c(1,3))
plot(five_sp_comp[,3], five_sp_comp[,5], xlab="Species 3",ylab="Species 5",main="Cross-species Correlation")

plot(sp3_ar_prediction, five_sp_comp[,3],xlab="Prediction using Species 3",ylab="Species 3 (true value)",main="Cross-species AR Model")
abline(a=1, b=1)

plot(sp3_observations, sp3_predictions,xlab="Prediction using Species 5",ylab="Species 3 (true value)",main="Cross-species S-Map")
abline(a=0,b=1)

par(mfrow=c(1,1))
```

# Code to produce figure 2:

```{r}


lib <- c(1,984)
pred <- c(985,999)
shlib <- c(685,700)
shpred <- c(701,715)


corr <- matrix(NA, ncol=8, nrow=5)
corr_sh  <- matrix(NA, ncol=8, nrow=5)
corr_com  <- matrix(NA, ncol=8, nrow=5)

win=700  #where to start in the time series
len=30

compred <- matrix(NA,nrow=5, ncol=2)
for(i in 1:5) {
	(1:5)[-i]->j
	compred[i,1:2]=c(i*1000-win-len/2,i*1000-win)
	comlib=matrix(c(i*1000-win-1,j*1000-win-len/2,i*1000-win+len/2,j*1000-win+len/2),nrow=5)
}

for (i in 1:5){
  simplex_mod_stats_sp <- simplex(five_sp_comp[,i+1], lib = lib, pred = pred,
                norm_type = c("L2 norm"), E = 1:8,
                tau = 1, tp = 1, num_neighbors = "e+1", stats_only = T,
                exclusion_radius = NULL, epsilon = NULL, silent = FALSE)
  corr[i,1:8] <- simplex_mod_stats_sp$rho 
}


for (i in 1:5){
  simplex_mod_stats_sp <- simplex(five_sp_comp[,i+1], lib = shlib, pred = shpred,
                norm_type = c("L2 norm"), E = 1:8,
                tau = 1, tp = 1, num_neighbors = "e+1", stats_only = T,
                exclusion_radius = NULL, epsilon = NULL, silent = FALSE)
  corr_sh[i,1:8] <- simplex_mod_stats_sp$rho 
}

library(reshape2)
t <- melt(five_sp_comp[,2:6])
t[1] <- 1:5000

for (i in 1:5){
  simplex_mod_stats_sp <- simplex(t[,2], lib = comlib, pred = compred[i,],
                norm_type = c("L2 norm"), E = 1:8,
                tau = 1, tp = 1, num_neighbors = "e+1", stats_only = T,
                exclusion_radius = NULL, epsilon = NULL, silent = FALSE)
  corr_com[i,1:8] <- simplex_mod_stats_sp$rho 
}

corr_D <- as.data.frame(t(apply(corr,2,quantile,probs=c(.025,.5,.975))))
corr_D$type <- "Long time series N=1000" 
corr_sh_D <-as.data.frame(t(apply(corr_sh,2,quantile,probs=c(.025,.5,.975))))
corr_sh_D$type <- "Short timeseries N=30" 
corr_com_D <- as.data.frame(t(apply(corr_com,2,quantile,probs=c(.025,.5,.975))))
corr_com_D$type <- "Composite timeseries N = 5 * 30" 

corr_D$D <- corr_sh_D$D <- corr_com_D$D <-  1:8

corr_D_full <- rbind(corr_D, rbind(corr_sh_D, corr_com_D))



```

## Figure 2:

```{r}
library(ggplot2)

ggplot() + geom_line(data=corr_D_full, aes(x=D, y=`50%`)) +
  geom_line(data=corr_D_full, aes(x=D, y=`2.5%`), colour="blue", linetype="dashed") + 
  geom_line(data=corr_D_full, aes(x=D, y=`97.5%`), colour="blue", linetype="dashed") + facet_grid(.~type) + ylab("Correlation")


```


## Figure 3:

```{r}
# check the predictions along theta

theta_list <- c(0,exp(0:9*.76753)*.01)
clib=matrix(c(1,31,61,91,30,60,90,120),nrow=4)
	
corr <- matrix(NA, ncol=11, nrow=5)
corr_sh  <- matrix(NA, ncol=11, nrow=5)
corr_com  <- matrix(NA, ncol=11, nrow=5)

corr_list <- vector("list", 100)
corr_sh_list <- vector("list", 100)
corr_com_list <- vector("list", 100)

for(i in 1:100) {
	floor(runif(1,30,969))->x
	pred=matrix(c(x,x+14),nrow=1)
	llib=matrix(c(1,x+15,x-1,999),nrow=2)
	shlib=matrix(c(x-15,x-1),nrow=1)

	for(j in 1:5) {
		t=as.vector(unlist(five_sp_comp[-15:14+x,c((2:6)[-j+1])]))
		
		corr[j,]=  smap_mod_stats_sp <- s_map(five_sp_comp[,j+1], lib = llib, pred = pred,
                norm_type = c("L2 norm"), E = 3, theta = theta_list,
                tau = 1, tp = 1, num_neighbors = "e+1", stats_only = T,
                exclusion_radius = NULL, epsilon = NULL, silent = FALSE)$rho
		corr_list[[i]] <- corr
	
		corr_sh[j,]=  smap_mod_stats_sp <- s_map(five_sp_comp[,j+1], lib = shlib, pred = pred,
                norm_type = c("L2 norm"), E = 3, theta = theta_list,
                tau = 1, tp = 1, num_neighbors = "e+1", stats_only = T,
                exclusion_radius = NULL, epsilon = NULL, silent = FALSE)$rho
		corr_sh_list[[i]] <- corr_sh	
		
		corr_com[j,]=  smap_mod_stats_sp <- s_map(length(t), lib = clib, pred = matrix(c(121,149),nrow=1),
                norm_type = c("L2 norm"), E = 3, theta = theta_list,
                tau = 1, tp = 1, num_neighbors = "e+1", stats_only = T,
                exclusion_radius = NULL, epsilon = NULL, silent = FALSE)$rho
		corr_com_list[[i]] <- corr_com

		
	}
}



library(dplyr)

for (k in 1:5){
corr_theta_df <- data.frame(matrix(unlist(lapply(corr_list, `[`,k,)), nrow=100, byrow=T))
corr_sh_theta_df <- data.frame(matrix(unlist(lapply(corr_sh_list, `[`,k,)), nrow=100, byrow=T))
corr_com_theta_df <- data.frame(matrix(unlist(lapply(corr_com_list, `[`,k,)), nrow=100, byrow=T))
}
t


corr_theta <- as.data.frame(t(apply(corr_theta_df,2,quantile,probs=c(.025,.5,.975))))
corr_theta$type <- "Long time series N=1000" 
corr_sh_theta <-as.data.frame(t(apply(corr_sh_theta_df,2,quantile,probs=c(.025,.5,.975))))
corr_sh_theta$type <- "Short timeseries N=30" 
corr_com_theta <- as.data.frame(t(apply(corr_com_theta_df,2,quantile,probs=c(.025,.5,.975))))
corr_com_theta$type <- "Composite timeseries N = 5 * 30" 

corr_theta$theta <- corr_sh_theta$theta <- corr_com_theta$theta <-  theta_list

corr_theta_full <- rbind(corr_theta, rbind(corr_sh_theta, corr_com_theta))

```

```{r}
library(ggplot2)

ggplot() + geom_line(data=corr_theta_full, aes(x=theta, y=`50%`)) +
  geom_line(data=corr_theta_full, aes(x=theta, y=`2.5%`), colour="blue", linetype="dashed") + 
  geom_line(data=corr_theta_full, aes(x=theta, y=`97.5%`), colour="blue", linetype="dashed") + facet_grid(.~type) + ylab("Correlation") + scale_x_continuous(trans="log10")


```



