---
title: "Reproducing 'Predicting the stability of large structured food webs' by Stefano Allesina et al. (2015, *Nature Communications*)"
author: "Thomas, Vanessa, Gian Marco, Owen"
date: "17 Sep 2015"
output: html_document
---



## Abstract
*"The stability of ecological systems has been a long-standing focus of ecology. Recently, tools from random matrix theory have identified the main drivers of stability in ecological communities whose network structure is random. However, empirical food webs differ greatly from random graphs. For example, their degree distribution is broader, they contain few trophic cycles, and they are almost interval. **Here we derive an approximation for the stability of food webs whose structure is generated by the cascade model, in which ‘larger’ species consume ‘smaller’ ones. **We predict the stability of these food webs with great accuracy, and our approximation also works well for food webs whose structure is determined empirically or by the niche model. **We find that intervality and broad degree distributions tend to stabilize food webs, and that average interaction strength has little influence on stability, compared with the effect of variance and correlation**."*

The articel can be found [here](http://www.nature.com/ncomms/2015/150722/ncomms8842/full/ncomms8842.html?WT.ec_id=NCOMMS-20150729&spMailingID=49200939&spUserID=ODkwMTM2NjQyNgS2&spJobID=723804686&spReportId=NzIzODA0Njg2S0) and in the respective GitHub folder.


## Initial comments
* The code to generate the food webs was done by Owen and taken from [TheTrophicLink](http://www.thetrophiclink.org/resources/food-web/).


## Set up environment

Clear workspace.
```{r}
rm(list=ls())
```

Load required packages.
```{r}
library("lattice")
library("igraph")
library("plyr")
library("HiveR")
library("RColorBrewer")
library("bipartite")
library("RCurl")
```


## Basic parameters
Species richness (S), connectance (C), number of food webs to be generated, number of links (L), and complexity (K).
```{r}
S = 50     # set species richness
C = 0.1    # set connectance, L/S^2
N = 10    # set the number of replicate webs to make
L = S^2*C  # calculate number of links from S and C
K = L/S    # complexity: L/S or (S^2*C)/S = S*C!
```



## Important functions
The function that generates N food webs. 
```{r}
## Make N niche model food web with S species and L links
## The output is a matrix if N=1 or a list of matrices if N>1
## Niche model of Williams and Martinez
## No check for desired connectance
## Make N cascade food webs with S species and L links
## The output is a matrix if N=1 or a list of matrices if N>1
## The cascade model is that of Cohen et al
Cascade.model <- function(S, L, N=1){
    if(N==1){
        web <- matrix(0, S, S)
        web[upper.tri(web)] <- c(rep(1, L), rep(0, (S^2-S)/2-L))[order(runif((S^2-S)/2))]
        dimnames(web) <- list(1:length(web[,1]), 1:length(web[,1]))
    }
    if(N>1){
        web <- list()
        for(i in 1:N){
            web[[i]] <- matrix(0, S, S)
            web[[i]][upper.tri(web[[i]])] <- c(rep(1, L), rep(0, (S^2-S)/2-L))[order(runif((S^2-S)/2))]
            dimnames(web[[i]]) <- list(1:length(web[[i]][,1]), 1:length(web[[i]][,1]))
        }
    }
    web
}
```

  

## Making the food webs
Make N food webs.
```{r}
Cascade.based.webs <- Cascade.model(S, L, N)
```


Takes a food web in matrix format and coverts it to list format.
```{r}
Matrix.to.list <- function(web.matrix, predator.first=TRUE){
  if(length(dimnames(web.matrix)[[1]])==length(web.matrix[1,]))
    species.names <- dimnames(web.matrix)[[1]]
  else
    species.names <- 1:length(web.matrix[,1])
  web.list <- matrix(0, sum(web.matrix), 2)
  counter <- 1
  for(i in 1:length(web.matrix[,1]))
    for(j in 1:length(web.matrix[,1]))
      if(web.matrix[i,j]==1){
        web.list[counter,] <- c(species.names[i],species.names[j])
        counter <- counter + 1
      }
  if(!predator.first)
    web.list <- cbind(web.list[,2], web.list[,1])
  web.list
}
```


Code to plot a adjacency matrix.
```{r}
pch.type=20
Plot.matrix <- function(web, title=" ", point.cex=0.2, trait.cex=1,
                        diag.line=T, traits=F, by.consumer=T, axes.labels=F, sp.pt.ch=NA){
    
  S <- length(web[,1])
  
  dimnames(web) <- list(1:S, 1:S)
  consumer <- rep(1:S, each=S)
  resource <- rep(1:S, S)
  web.list <- Matrix.to.list(web)
  par(xpd=T)
  plot(consumer, resource, pch=pch.type, type="n", cex=0.1,
       ann=F, axes=F,
       xlim=c(1, S), ylim=c(1, S))
  if(length(traits)==1)
    points(web.list[,2], S+1-as.numeric(web.list[,1]),
           type="p", pch=pch.type, cex=point.cex)
  if(length(traits)==length(web)){

    colours.to.use <- rev(heat.colors(30)[c(-1:-5, -26:-30)])
    ##colours.to.use <- rev(gray(1:30/30)[c(-1:-5, -26:-30)])
    
    if(by.consumer){
      integer.traits <- matrix(0, S, S)
      for(i in 1:S){
        traits.01 <- traits[,i]-min(traits[,i])
        traits.01 <- traits.01/max(traits.01)
        integer.traits[,i] <- round(traits.01*19)+1
        integer.traits[traits[,i]==0,i] = NaN
        
      }
    }
    
    if(!by.consumer){
      colours.to.use <- heat.colors(20)
      traits.01 <- traits-min(traits)
      traits.01 <- traits.01/max(traits.01)
      integer.traits <- round(traits.01*19)+1
    }

    if(point.cex>trait.cex){
        points(web.list[,2], S+1-as.numeric(web.list[,1]),
               type="p", pch=pch.type, cex=point.cex, col="black")##colours.to.use[integer.traits])
        points(rep(1:S, each=S), rep(S:1, times=S), 
               pch=pch.type, cex=trait.cex, col=colours.to.use[integer.traits])
    }
    if(point.cex<trait.cex){
        points(rep(1:S, each=S), rep(S:1, times=S), 
               pch=pch.type, cex=trait.cex, col=colours.to.use[integer.traits])
        points(web.list[,2], S+1-as.numeric(web.list[,1]),
               type="p", pch=pch.type, cex=point.cex, col="black")##colours.to.use[integer.traits])
    }

    if(!is.na(sp.pt.ch))
        points(web.list[,2], S+1-as.numeric(web.list[,1]),
               type="p", pch=sp.pt.ch, cex=point.cex, col="black")##colours.to.use[integer.traits])
        
    
  }
  par(xpd=F)
  mtext(side=3, text=title, font=2, line=2, cex=0.5)
  if(axes.labels){
      mtext(side=2, "Resource", line=0.5, cex=1)
      mtext(side=3, "Consumer", line=0.5, cex=1)
  }
  if(diag.line==T)
    lines(1:S, S:1, lty="dashed")
}  
```  
  

## Plot adjancency matrices
This is what the adjacency matrix (displaying who eats whom) looks like for 9 food webs.
```{r}
par(mar=c(2,2,2,2))
layout(matrix(1:9, 3, 3), respect=T)
for(i in 1:9){
    Plot.matrix(Cascade.based.webs[[i]])
    box()
}  
# layout(matrix(1:1, 1, 1), respect=T)
# Plot.matrix(Cascade.based.webs[[1]])
```


## Who eats whom?
Display food web(s).
```{r}
g1 <- graph.adjacency(Cascade.based.webs[[1]])
# plot.igraph(g1, 
#      layout=layout.circle, 
#      main="Experimental food web (no information)",
#      vertex.size=15, 
#      vertex.color=adjustcolor("#A6B07E", alpha.f=0.6),
#      vertex.label.cex=0.7,
#      vertex.label.family = "sans",
#      edge.width=2, 
#      vertex.label.color="#7D1D3F",
#      vertex.frame.color="white")
layout(matrix(1:1, 1, 1), respect=T)
plot.igraph(g1, 
#      layout=layout.reingold.tilford(g1, flip.y=FALSE),
     layout=layout.fruchterman.reingold,
     main="",
     vertex.color=adjustcolor("#3C787E", alpha.f=0.4),
     vertex.size=3, 
     vertex.label.cex=0.5,
     vertex.label.family = "sans",
     vertex.label.color="#C7EF00",
#      vertex.label.color="#7D1D3F",
     vertex.frame.color="#FFFFFF",
     edge.color=adjustcolor("#666666", alpha.f=0.7),
     edge.width=0.5, 
     edge.arrow.size=0.2, 
     edge.arrow.width=0.05)
```

```{r}
par(mar=c(2,2,2,2))
layout(matrix(1:9, 3, 3), respect=T)
for(i in 1:9){
g1 <- graph.adjacency(Cascade.based.webs[[i]])
plot.igraph(g1, 
     layout=layout.fruchterman.reingold,
     main="",
     vertex.color=adjustcolor("#3C787E", alpha.f=0.4),
     vertex.size=3, 
     vertex.label.cex=0.5,
     vertex.label.family = "sans",
     vertex.label.color="#C7EF00",
#      vertex.label.color="#7D1D3F",
     vertex.frame.color="#FFFFFF",
     edge.color=adjustcolor("#666666", alpha.f=0.7),
     edge.width=0.5, 
     edge.arrow.size=0.2, 
     edge.arrow.width=0.05)
# plot.igraph(g1, 
# #      layout=layout.reingold.tilford(g1, flip.y=FALSE),
#      layout=layout.circle,
#      main="",
#      vertex.color=adjustcolor("#A6B07E", alpha.f=0.6),
#      vertex.size=30, 
#      vertex.label.cex=1,
#      vertex.label.family = "sans",
#      vertex.label.color="#7D1D3F",
#      vertex.frame.color="#FFFFFF",
#      edge.color="#666666",
#      edge.width=1, 
#      edge.arrow.size=0.5, 
#      edge.arrow.width=0.3)
}
```  
  
  
## Bivariate distribution Z
Now, one needs to construct the bivariate distribution based on size ratios. For this purpose, Allesina et al. were using the data set provided by [Brose et al. (2005, Ecology)](http://www.esajournals.org/doi/pdf/10.1890/05-0379).

This reads in the data.
```{r}
dd.temp <-  getURL("https://raw.githubusercontent.com/opetchey/RREEBES/ALLESINA_etal_2015_NatComm/ALLESINA_etal_2015_NatComm/Data/BodySizes_Brose2005_revised2008.csv",
             cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl"))
dd.sizes <- read.csv(text = dd.temp)
```

These are the categories of this data set.
```{r}
print(colnames(dd.sizes))
```


```{r}

```


```{r}  
x     <- seq(-3,3, by=0.05)
y     <- seq(-3,3, by=0.05)
mu.x  <- -1
mu.y  <- 0.35
sig.x <- 1.23
sig.y <- 0.46
rho   <- -0.67

Z <- matrix(0, nrow=length(x), ncol=length(y))

for (i in 1:length(x)) {
  
  for (j in 1:length(y)) {
  
    Z[i,j] <- ((x[i]-mu.x)^2)/sig.x^2 -
              2*rho*((x[i]-mu.x)*(y[j]-mu.y))/(sig.x*sig.y) +
              ((y[j]-mu.y)^2)/sig.y^2
  }
}

```    



```{r}

```



  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  